// GOOGLE APPS SCRIPT - BKK INTEGRATED TURBO V11.5 (FIXED LOGIC)

function doGet(e) {
  var action = e.parameter.action || "getData";
  var ssId = "17rIBNXdJOQkuizl_gJ5jGid7oqiEfJdWxUgPtz-i3As";
  
  try {
    if (action === "getDowntimeQuery") {
      return getDowntimeQuery(ssId, e);
    } 
    else if (action === "debugRaw") {
      return debugRawData(ssId, e);
    }
    else {
      return getOutstandingBKKTurbo(ssId, e);
    }
  } catch (err) {
    return createOutput({error: err.toString(), status: "error"}, e);
  }
}

/**
 * DEBUG: Dump raw cell values, types, and headers from DOWNTIME sheet
 */
function debugRawData(ssId, e) {
  var ss = SpreadsheetApp.openById(ssId);
  var sheet = ss.getSheetByName("DOWNTIME");
  var lastRow = sheet.getLastRow();
  var lastCol = sheet.getLastColumn();
  
  var headerRange = sheet.getRange(1, 1, Math.min(5, lastRow), Math.min(lastCol, 25));
  var headers = headerRange.getValues();
  
  var sampleStart = 5;
  var sampleCount = Math.min(5, lastRow - sampleStart + 1);
  var sampleRows = [];
  if (sampleCount > 0) {
    var rawSample = sheet.getRange(sampleStart, 1, sampleCount, Math.min(lastCol, 25)).getValues();
    for (var i = 0; i < rawSample.length; i++) {
      var row = [];
      for (var j = 0; j < rawSample[i].length; j++) {
        var cell = rawSample[i][j];
        row.push({
          col: j,
          val: cell instanceof Date ? cell.toISOString() : String(cell),
          type: cell instanceof Date ? "Date" : typeof cell
        });
      }
      sampleRows.push(row);
    }
  }
  
  return createOutput({
    lastRow: lastRow,
    lastCol: lastCol,
    headers: headers.map(function(r) { return r.map(String); }),
    sampleRows: sampleRows
  }, e);
}

/**
 * ROBUST DATE PARSER (V7.4 ORIGINAL)
 */
function parseDate(val) {
  if (!val) return null;
  if (val instanceof Date) {
    if (isNaN(val.getTime())) return null;
    return val;
  }
  var s = val.toString().trim();
  if (!s || s === "-" || s === "0") return null;
  var m1 = s.match(/^(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{4})$/);
  if (m1) {
    var day = parseInt(m1[1], 10);
    var mon = parseInt(m1[2], 10);
    var yr  = parseInt(m1[3], 10);
    if (mon >= 1 && mon <= 12 && day >= 1 && day <= 31 && yr >= 2000) {
      return new Date(yr, mon - 1, day);
    }
  }
  var m2 = s.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/);
  if (m2) {
    var yr2  = parseInt(m2[1], 10);
    var mon2 = parseInt(m2[2], 10);
    var day2 = parseInt(m2[3], 10);
    if (mon2 >= 1 && mon2 <= 12 && day2 >= 1 && day2 <= 31 && yr2 >= 2000) {
      return new Date(yr2, mon2 - 1, day2);
    }
  }
  var num = parseFloat(s);
  if (!isNaN(num) && num > 40000 && num < 60000) {
    var epoch = new Date(1899, 11, 30);
    epoch.setDate(epoch.getDate() + num);
    return epoch;
  }
  var d = new Date(s);
  if (!isNaN(d.getTime()) && d.getFullYear() >= 2000) return d;
  return null;
}

/**
 * ROBUST NETTO PARSER (V7.4 ORIGINAL)
 */
function parseNetto(val) {
  if (val === null || val === undefined || val === "" || val === "-") return 0;
  if (typeof val === "number") return val;
  var s = val.toString().trim().replace(/\s/g, "");
  if (!s) return 0;
  var hasDot   = s.indexOf(".") !== -1;
  var hasComma = s.indexOf(",") !== -1;
  if (hasDot && hasComma) {
    var lastDot   = s.lastIndexOf(".");
    var lastComma = s.lastIndexOf(",");
    if (lastComma > lastDot) s = s.replace(/\./g, "").replace(",", ".");
    else s = s.replace(/,/g, "");
  } else if (hasComma && !hasDot) {
    var parts = s.split(",");
    if (parts.length === 2 && parts[1].length === 3) s = s.replace(/,/g, "");
    else s = s.replace(",", ".");
  } else if (hasDot && !hasComma) {
    var dotParts = s.split(".");
    if (dotParts.length === 2 && dotParts[1].length === 3 && dotParts[0].length >= 2) s = s.replace(/\./g, "");
    else if (dotParts.length > 2) s = s.replace(/\./g, "");
  }
  var result = parseFloat(s);
  return isNaN(result) ? 0 : result;
}

/**
 * ROBUST TIME/DURATION PARSER (V12.5)
 */
function parseTime(t) {
  if (t === null || t === undefined || t === "" || t === "-" || t === "0" || t === 0) return 0;
  
  if (t instanceof Date) {
    if (isNaN(t.getTime())) return 0;
    // Google Sheets durations are often Date objects starting from 1899-12-30
    // We care about the time relative to the start of the day
    return (t.getHours() * 60) + t.getMinutes() + (t.getSeconds() / 60);
  }
  
  if (typeof t === "number") {
    // If it's a small number (< 1), it's likely a day fraction from a duration cell
    if (t > 0 && t <= 1) return t * 1440;
    // Otherwise treat as SECONDS (as per user's earlier specification for Manuver/QC)
    return t; // Default to minutes
  }
  
  var str = t.toString().trim();
  if (!str) return 0;
  if (str.indexOf(":") !== -1) {
    var parts = str.split(":");
    var h = parseFloat(parts[0]) || 0;
    var m = parseFloat(parts[1]) || 0;
    var s = parts.length > 2 ? (parseFloat(parts[2]) || 0) : 0;
    return (h * 60) + m + (s / 60);
  }
  
  var num = parseFloat(str.replace(",", "."));
  return isNaN(num) ? 0 : num; // Default to minutes
}

function getDowntimeQuery(ssId, e) {
  var ss = SpreadsheetApp.openById(ssId);
  var sheet = ss.getSheetByName("DOWNTIME");
  
  var targetMonth = parseInt(e.parameter.month); 
  var targetYear = parseInt(e.parameter.year);   
  var matFilter = (e.parameter.material || "").toUpperCase();
  var lastRow = sheet.getLastRow();
  var totalRowsToScan = Math.min(10000, lastRow - 5 + 1); 
  var startRow = Math.max(5, lastRow - totalRowsToScan + 1);
  
  if (totalRowsToScan <= 0) return createOutput({data: [], materials: [], status: "empty_sheet"}, e);

  var rawData = sheet.getRange(startRow, 1, totalRowsToScan, 25).getValues();
  var dailyAgg = {}; 
  var materials = new Set();
  
  // ======== V11.5 SEPARATED COLLECTORS ========
  var materialNetto = {};   
  var intakeTruckTypes = {}; // V11.5: Clean separation
  var directTruckTypes = {}; // V11.5: Clean separation
  var intake71Trucks = [];  // for idle gap analysis
  var i71TotalNetto = 0;
  var i71TotalMan = 0;      
  var i71TotalQC = 0;       
  var i71TruckCount = 0;
  var i71MaterialNetto = {};
  var i71ActiveTotalGenerated = 0; 
  var i71MinSpeed = 9999;
  var i71MaxSpeed = 0;
  var i71TotalSpeedSum = 0;
  var i71SpeedValidCount = 0;
  var intakeSubTypes = {};  // V14: TILTING vs MANUAL breakdown
  var i71DailyDetail = {};  // V14: per-day active/idle/off
  var workerStats = {};     // V14: worker count breakdown
  
  var directDailyAgg = {};
  var directMaterialNetto = {};
  var directTruckTypes = {};
  var directTotalNetto = 0;
  var directTotalTrucks = 0;
  
  for (var i = 0; i < rawData.length; i++) {
    var rawMat = (rawData[i][9] || "").toString().trim().toUpperCase();
    if(rawMat) materials.add(rawMat);
    
    var rowDate = parseDate(rawData[i][0]);
    if (!rowDate) continue;
    
    var m = rowDate.getMonth() + 1;
    var y = rowDate.getFullYear();
    if (targetMonth && targetYear) {
      if (m !== targetMonth || y !== targetYear) continue;
    }
    if (matFilter && rawMat.indexOf(matFilter) !== 0) continue;
    
    var dateKey = Utilities.formatDate(rowDate, "GMT+7", "yyyy-MM-dd");
    var rowNetto = parseNetto(rawData[i][8]);
    var type = (rawData[i][1] || "").toUpperCase();
    var truckType = (rawData[i][6] || "").toString().trim().toUpperCase() || "UNKNOWN";
    
    // ---- Material & truck type breakdowns (V7.4) ----
    if (rawMat) { materialNetto[rawMat] = (materialNetto[rawMat] || 0) + rowNetto; }
    
  // ---- Global Daily aggregation ----
    if (!dailyAgg[dateKey]) {
      dailyAgg[dateKey] = {
        date: dateKey, netto: 0, trucks: 0, cycleMin: 0,
        intakeNetto: 0, directNetto: 0
      };
    }
    var d = dailyAgg[dateKey];
    d.netto += rowNetto;
    d.trucks++;
    if (type.indexOf("INTAKE") !== -1) d.intakeNetto += rowNetto;
    else d.directNetto += rowNetto;
    
    var pt_m = parseTime(rawData[i][13]);
    var pb_m = parseTime(rawData[i][16]);
    
    // V11.4: Use only PB (Proses Bongkar) for duration
    var rowDur = pb_m;
    d.cycleMin += rowDur;
    
    // V11.9: Strict Path & synchronized logic
    var isI71 = (type.indexOf("INTAKE 71") !== -1);
    var isDG = (type === "DIRECT GUDANG");
    
    if ((isI71 || isDG) && truckType && truckType !== "UNKNOWN") {
      var targetColl = isI71 ? intakeTruckTypes : directTruckTypes;
      
      if (!targetColl[truckType]) {
        targetColl[truckType] = { trucks: 0, netto: 0, duration: 0, min: 9999, max: 0, validDurCount: 0 };
      }
      var tts = targetColl[truckType];
      tts.trucks++; 
      tts.netto += rowNetto;
      
      // V11.8+11.9: Strict non-zero handling for Min/Avg
      if (rowDur > 0) {
        tts.duration += rowDur;
        tts.validDurCount++;
        if (rowDur < tts.min) tts.min = rowDur;
        if (rowDur > tts.max) tts.max = rowDur;
      }
    }

    // ---- INTAKE 71 specific with V12 Logic ----
    if (type.indexOf("INTAKE 71") !== -1) {
      var startTs = rawData[i][14]; // Bongkar Mulai
      var endTs = rawData[i][15];   // Bongkar Selesai
      
      if (startTs instanceof Date && endTs instanceof Date && !isNaN(startTs.getTime()) && !isNaN(endTs.getTime())) {
        var day = rowDate.getDate();
        var absStart = ((day - 1) * 24 * 60) + (startTs.getHours() * 60) + startTs.getMinutes() + (startTs.getSeconds() / 60);
        var absEnd = ((day - 1) * 24 * 60) + (endTs.getHours() * 60) + endTs.getMinutes() + (endTs.getSeconds() / 60);
        
        var duration = absEnd - absStart;
        if (duration > 0 && duration < 600) {
          i71TotalNetto += rowNetto;
          i71TruckCount++;
          
          // V13.2: BULLETPROOF Manuver/QC parsing
          var rowMan = 0;
          var rowQC = 0;
          var manS = rawData[i][17];
          var manE = rawData[i][18];
          if (manS instanceof Date && manE instanceof Date && !isNaN(manS.getTime()) && !isNaN(manE.getTime())) {
            var manDiff = ((manE.getHours() * 60) + manE.getMinutes() + (manE.getSeconds() / 60)) -
                          ((manS.getHours() * 60) + manS.getMinutes() + (manS.getSeconds() / 60));
            if (manDiff > 0 && manDiff < 600) rowMan = manDiff;
          }
          var qcS = rawData[i][20];
          var qcE = rawData[i][21];
          if (qcS instanceof Date && qcE instanceof Date && !isNaN(qcS.getTime()) && !isNaN(qcE.getTime())) {
            var qcDiff = ((qcE.getHours() * 60) + qcE.getMinutes() + (qcE.getSeconds() / 60)) -
                         ((qcS.getHours() * 60) + qcS.getMinutes() + (qcS.getSeconds() / 60));
            if (qcDiff > 0 && qcDiff < 600) rowQC = qcDiff;
          }
          var manQcSum = rowMan + rowQC;
          if (manQcSum > duration && manQcSum > 0) {
            var scale = duration / manQcSum;
            rowMan = rowMan * scale;
            rowQC = rowQC * scale;
          }
          
          i71TotalMan += rowMan;
          i71TotalQC += rowQC;
          i71ActiveTotalGenerated += duration;
          
          var truckSpeed = duration > 0 ? (rowNetto / 1000) / (duration / 60) : 0;
          if (truckSpeed > 0) {
            if (truckSpeed < i71MinSpeed) i71MinSpeed = truckSpeed;
            if (truckSpeed > i71MaxSpeed) i71MaxSpeed = truckSpeed;
            i71TotalSpeedSum += truckSpeed;
            i71SpeedValidCount++;
          }
          
          if (rawMat) { i71MaterialNetto[rawMat] = (i71MaterialNetto[rawMat] || 0) + rowNetto; }
          
          intake71Trucks.push({ 
            start: absStart, end: absEnd, mat: rawMat, day: day,
            code: (rawData[i][10] || "").toString().trim().toUpperCase() 
          });
          
          // V14: Intake sub-type (TILTING vs MANUAL)
          var subType = type.indexOf("TILTING") !== -1 ? "TILTING" : "MANUAL";
          if (!intakeSubTypes[subType]) intakeSubTypes[subType] = { trucks: 0, netto: 0, duration: 0 };
          intakeSubTypes[subType].trucks++;
          intakeSubTypes[subType].netto += rowNetto;
          intakeSubTypes[subType].duration += duration;
          
          // V14: Daily detail for intake
          if (!i71DailyDetail[dateKey]) i71DailyDetail[dateKey] = { date: dateKey, netto: 0, trucks: 0, activeMin: 0 };
          i71DailyDetail[dateKey].netto += rowNetto;
          i71DailyDetail[dateKey].trucks++;
          i71DailyDetail[dateKey].activeMin += duration;
          
          // V14: Worker count stats (col 23)
          var wCount = parseInt(rawData[i][23]) || 0;
          if (wCount > 0) {
            var wKey = wCount.toString();
            if (!workerStats[wKey]) workerStats[wKey] = { count: wCount, totalNetto: 0, trucks: 0, totalDur: 0 };
            workerStats[wKey].totalNetto += rowNetto;
            workerStats[wKey].trucks++;
            workerStats[wKey].totalDur += duration;
          }
        }
      }
    }
    
    // ---- DIRECT GUDANG collectors (V7.4) ----
    if (type.includes("DIRECT")) {
      directTotalNetto += rowNetto;
      directTotalTrucks++;
      if (rawMat) { directMaterialNetto[rawMat] = (directMaterialNetto[rawMat] || 0) + rowNetto; }
      
      // Removed: redundant directTruckTypes calculation here, now handled in global loop (V11.5)
      
      if (!directDailyAgg[dateKey]) {
        directDailyAgg[dateKey] = { date: dateKey, netto: 0, trucks: 0 };
      }
      var dd = directDailyAgg[dateKey];
      dd.netto += rowNetto;
      dd.trucks++;
    }
  }
  
  // ======== INTAKE 71 REAL-TIME TIMELINE LOGIC (V12.4) ========
  var now = new Date();
  var totalMonthMin;
  
  // Real-Time Calendar Minutes: If today is in the target month/year, only count up to 'now'
  if (now.getFullYear() === targetYear && (now.getMonth() + 1) === targetMonth) {
    totalMonthMin = ((now.getDate() - 1) * 1440) + (now.getHours() * 60) + now.getMinutes();
  } else {
    totalMonthMin = (new Date(targetYear, targetMonth, 0).getDate()) * 1440;
  }
  
  var idleMin = 0;
  var offMin = 0;
  
  if (intake71Trucks.length > 0) {
    intake71Trucks.sort(function(a, b) { return a.start - b.start; });
    
    // Gap before first truck
    offMin += intake71Trucks[0].start;
    
    // Gaps between trucks
    for (var j = 0; j < intake71Trucks.length - 1; j++) {
      var curr = intake71Trucks[j];
      var next = intake71Trucks[j+1];
      var gap = next.start - curr.end;
      
      if (gap > 0) {
        if (curr.mat === next.mat && curr.code === next.code) {
          idleMin += gap;
        } else {
          offMin += gap;
        }
      }
    }
    
    // Gap after last truck (up to totalMonthMin)
    var lastEnd = intake71Trucks[intake71Trucks.length - 1].end;
    if (totalMonthMin > lastEnd) offMin += (totalMonthMin - lastEnd);
  } else {
    offMin = totalMonthMin;
  }
  
  // SCALE & BALANCE TO CALENDAR MINUTES (V12.4 Integrity Fix)
  // Active = total stay from Start to End. 
  // Net = Active - Manuver - QC.
  var leftover = Math.max(0, totalMonthMin - i71ActiveTotalGenerated);
  var gapTotal = idleMin + offMin;
  var finalIdle = gapTotal > 0 ? (idleMin / gapTotal) * leftover : 0;
  var finalOff = leftover - finalIdle;
  
  // V14: Build daily detail with idle/off per day
  var i71DailyArr = [];
  var dayTrucks = {};
  intake71Trucks.forEach(function(t) { 
    if (!dayTrucks[t.day]) dayTrucks[t.day] = [];
    dayTrucks[t.day].push(t);
  });
  Object.keys(i71DailyDetail).forEach(function(dk) {
    var dd = i71DailyDetail[dk];
    var dayNum = parseInt(dk.split("-")[2]);
    var trucks = dayTrucks[dayNum] || [];
    var dayIdle = 0, dayOff = 0;
    if (trucks.length > 0) {
      trucks.sort(function(a,b) { return a.start - b.start; });
      for (var j = 0; j < trucks.length - 1; j++) {
        var gp = trucks[j+1].start - trucks[j].end;
        if (gp > 0) {
          if (trucks[j].mat === trucks[j+1].mat && trucks[j].code === trucks[j+1].code) dayIdle += gp;
          else dayOff += gp;
        }
      }
    }
    dd.idleMin = Math.round(dayIdle);
    dd.offMin = Math.round(dayOff);
    dd.activeMin = Math.round(dd.activeMin);
    dd.tonPerHour = dd.activeMin > 0 ? Math.round(((dd.netto / 1000) / (dd.activeMin / 60)) * 10) / 10 : 0;
    i71DailyArr.push(dd);
  });
  i71DailyArr.sort(function(a,b) { return a.date.localeCompare(b.date); });
  
  var intake71 = {
    activeTotal: Math.round(i71ActiveTotalGenerated),
    netDischarge: Math.round(Math.max(0, i71ActiveTotalGenerated - i71TotalMan - i71TotalQC)),
    manuverTotal: Math.round(i71TotalMan),
    qcTotal: Math.round(i71TotalQC),
    idleLoss: Math.round(finalIdle),
    offSetup: Math.round(finalOff),
    activePct: (i71ActiveTotalGenerated / totalMonthMin) * 100,
    idlePct: (finalIdle / totalMonthMin) * 100,
    offPct: (finalOff / totalMonthMin) * 100,
    trucks: i71TruckCount,
    nettoKg: Math.round(i71TotalNetto),
    materials: i71MaterialNetto,
    avgSpeed: i71SpeedValidCount > 0 ? (i71TotalSpeedSum / i71SpeedValidCount) : 0,
    minSpeed: i71MinSpeed === 9999 ? 0 : i71MinSpeed,
    maxSpeed: i71MaxSpeed,
    totalMonthMin: totalMonthMin,
    intakeSubTypes: intakeSubTypes,
    dailyDetail: i71DailyArr,
    workerStats: workerStats
  };
  
  // ======== BUILD RESULT (PRESERVED) ========
  var result = Object.values(dailyAgg).sort(function(a,b) { return a.date.localeCompare(b.date); }).map(function(s) {
    return {
      date: s.date,
      netto: Math.round(s.netto),
      trucks: s.trucks,
      avgCycle: s.cycleMin / s.trucks,
      dist: { 
        intake: Math.round((s.intakeNetto / s.netto) * 100) || 0, 
        direct: Math.round((s.directNetto / s.netto) * 100) || 0 
      }
    };
  });
  
  var directDaily = Object.keys(directDailyAgg).sort().map(function(k) {
    var s = directDailyAgg[k];
    return { date: s.date, netto: Math.round(s.netto), trucks: s.trucks };
  });

  return createOutput({
    status: "success",
    data: result,
    materialBreakdown: materialNetto,
    truckTypes: intakeTruckTypes, // V11.5: Specifically Intake
    intake71: intake71,
    directGudang: {
      totalNetto: Math.round(directTotalNetto),
      totalTrucks: directTotalTrucks,
      daily: directDaily,
      materials: directMaterialNetto,
      truckTypes: directTruckTypes // V11.5: Specifically Direct
    },
    materials: Array.from(materials).sort()
  }, e);
}

function getOutstandingBKKTurbo(ssId, e) {
  var ss = SpreadsheetApp.openById(ssId);
  var sheet = ss.getSheetByName("Monitoring bongkaran");
  var allValues = sheet.getRange(1, 1, 250, 9).getValues();

  var intakeData = [
    { name: allValues[1][1], status: allValues[2][1], material: allValues[3][1] },
    { name: allValues[1][2], status: allValues[2][2], material: allValues[3][2] }
  ];

  var silos = [];
  for (var col = 0; col < 6; col++) {
    var c = 3 + col; 
    silos.push({
      id: ["BK1","BK2","BK3","BK4","BK5","BK6"][col], 
      material: allValues[6][c], vessel: allValues[7][c], 
      stock: allValues[8][c], percentage: allValues[9][c],
      age: allValues[10][c], status: allValues[13][c]
    });
  }

  var truckData = [];
  for (var i = 21; i < allValues.length; i++) {
    if (!allValues[i][2] && !allValues[i][3]) continue; 
    truckData.push({
      material: allValues[i][2], netto: allValues[i][4], type: allValues[i][5], aging: allValues[i][7],
      nopol: (allValues[i][3] || "").toString().split(/\d{2}[-./]/)[1]?.trim() || allValues[i][3]
    });
  }

  return createOutput({ intake: intakeData, silos: silos, trucks: truckData }, e);
}

function createOutput(result, e) {
  var jsonString = JSON.stringify(result);
  var cb = (e && e.parameter && e.parameter.callback) ? e.parameter.callback : null;
  if (cb) {
    return ContentService.createTextOutput(cb + "(" + jsonString + ")")
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  } else {
    return ContentService.createTextOutput(jsonString).setMimeType(ContentService.MimeType.JSON);
  }
}
